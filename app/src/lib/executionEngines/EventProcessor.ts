/**
 * Event Processor - Core Execution Engine
 * 
 * This is the heart of the event-driven architecture. It:
 * 
 * 1. Pulls events from the event queue (chronological order)
 * 2. Routes events to appropriate node processors
 * 3. Collects new events generated by processors
 * 4. Adds new events back to queue and event store
 * 5. Updates node states
 * 
 * This engine is DETERMINISTIC:
 * - Same events + same scenario = same outputs
 * - Can be used for simulation, production, and replay
 * 
 * @module EventProcessor
 */

import { create } from 'zustand';
import { StoredEvent, useEventStore, setTickDuration, createEventAtTick } from '@/stores/eventStore';
import { EventQueue, useEventQueue } from '@/stores/eventQueue';
import { useReplayEngine } from '@/stores/replayEngine';
import { now as nowTimestamp, setTimeStrategy, setSimulationTime } from '@/lib/time/timestampService';
import { useActivityLogger } from '@/stores/activityLogger';
import {
  BaseNodeProcessor,
  NodeConfig,
  NodeInternalState,
  nodeProcessorRegistry,
} from '../nodeProcessors/BaseNodeProcessor';

// Import all processors to register them
import '../nodeProcessors/DataSourceProcessor';
import '../nodeProcessors/ProcessNodeProcessor';
import '../nodeProcessors/QueueProcessor';
import '../nodeProcessors/FSMProcessor';
import '../nodeProcessors/SinkProcessor';

// ============================================================================
// EXECUTION CONTEXT
// ============================================================================

/**
 * Execution context - scenario + node states
 */
export interface ExecutionContext {
  /** Scenario/diagram being executed */
  scenario: {
    nodes: any[];
    edges: any[];
  };
  
  /** Current state of all nodes */
  nodeStates: Map<string, NodeInternalState>;
  
  /** Edge lookup for routing data */
  edgeMap: Map<string, string[]>; // sourceNodeId -> targetNodeIds[]
  
  /** Configuration */
  config: {
    /** Max events to process (safety limit) */
    maxEvents?: number;
    
    /** Stop time (simulation time) */
    stopTime?: number;
    
    /** Real-time mode? (add delays between events) */
    realTimeMode?: boolean;
    
    /** Real-time speed multiplier */
    realTimeSpeed?: number;
  };
}

/**
 * Execution statistics
 */
export interface ExecutionStats {
  eventsProcessed: number;
  eventsByType: Record<string, number>;
  eventsByNode: Record<string, number>;
  startTime: number;
  endTime: number;
  duration: number;
  errors: number;
}

// ============================================================================
// EVENT PROCESSOR STORE
// ============================================================================

interface EventProcessorState {
  /** Current execution context */
  context: ExecutionContext | null;

  /** Is processor running? */
  isRunning: boolean;

  /** Current simulation tick */
  currentTick: number;

  /** Current simulation time (legacy) */
  currentTime: number;

  /** Execution statistics */
  stats: ExecutionStats;
  
  /** Errors encountered */
  errors: Array<{
    eventId: string;
    nodeId: string;
    error: Error;
    timestamp: number;
  }>;
  
  // ============================================================================
  // SETUP
  // ============================================================================
  
  /**
   * Initialize execution context with scenario
   */
  initialize: (scenario: any, config?: ExecutionContext['config']) => void;
  
  /**
   * Reset processor
   */
  reset: () => void;
  
  // ============================================================================
  // EXECUTION CONTROL
  // ============================================================================
  
  /**
   * Start processing events from queue
   */
  start: () => Promise<ExecutionStats>;
  
  /**
   * Stop processing
   */
  stop: () => void;
  
  /**
   * Process a single event
   */
  processEvent: (event: StoredEvent) => Promise<void>;
  
  /**
   * Process next event from queue
   */
  processNextEvent: () => Promise<boolean>;
  
  // ============================================================================
  // STATE QUERIES
  // ============================================================================
  
  /**
   * Get node state
   */
  getNodeState: (nodeId: string) => NodeInternalState | null;
  
  /**
   * Get all node states
   */
  getAllNodeStates: () => Map<string, NodeInternalState>;
  
  /**
   * Get execution stats
   */
  getStats: () => ExecutionStats;
  
  // ============================================================================
  // INTERNAL
  // ============================================================================
  
  _initializeNodeStates: () => void;
  _buildEdgeMap: () => void;
  _generateInitialEvents: () => void;
  _routeDataToTargets: (
    sourceNodeId: string,
    payload: any,
    timestamp: number,
    causedBy: string
  ) => Omit<StoredEvent, 'id'>[];
}

export const useEventProcessor = create<EventProcessorState>((set, get) => ({
  // Initial state
  context: null,
  isRunning: false,
  currentTick: 0,
  currentTime: 0,
  stats: {
    eventsProcessed: 0,
    eventsByType: {},
    eventsByNode: {},
    startTime: 0,
    endTime: 0,
    duration: 0,
    errors: 0,
  },
  errors: [],
  
  // ============================================================================
  // SETUP
  // ============================================================================
  
  initialize: async (scenario, config = {}) => {
    const context: ExecutionContext = {
      scenario,
      nodeStates: new Map(),
      edgeMap: new Map(),
      config,
    };

    // Set tick duration from config
    const tickDurationMs = (config as any).tickDurationMs || 1;
    setTickDuration(tickDurationMs);

    set({ context, currentTick: 0, currentTime: 0 });

    // Clear previous state
    const activityLogger = useActivityLogger.getState();
    activityLogger.clearLogs();

    const eventStore = useEventStore.getState();
    eventStore.clearEvents();

    const eventQueue = useEventQueue.getState();
    eventQueue.clear();

    // Initialize node states
    get()._initializeNodeStates();

    // Build edge map for routing
    get()._buildEdgeMap();

    // Set time strategy
    if (config && (config as any).timeStrategy === 'simulation') {
      setTimeStrategy('simulation');
      setSimulationTime(0);
    } else {
      setTimeStrategy('real');
    }

    // Pre-generate initial events
    get()._generateInitialEvents();

    console.log('‚úÖ Event processor initialized with tick-based architecture');
  },
  
  reset: () => {
    set({
      context: null,
      isRunning: false,
      currentTime: 0,
      stats: {
        eventsProcessed: 0,
        eventsByType: {},
        eventsByNode: {},
        startTime: 0,
        endTime: 0,
        duration: 0,
        errors: 0,
      },
      errors: [],
    });
    
    // Clear event queue and store
    useEventQueue.getState().clear();
    useEventStore.getState().clearEvents();
  },
  
  // ============================================================================
  // EXECUTION CONTROL
  // ============================================================================
  
  start: async () => {
    const { context } = get();

    if (!context) {
      throw new Error('No context set. Call initialize() first.');
    }

    const startTime = Date.now();

    set({
      isRunning: true,
      stats: {
        ...get().stats,
        startTime,
      },
    });

    const eventQueue = useEventQueue.getState();
    const maxEvents = context.config.maxEvents || 100000;
    const stopTick = context.config.stopTime || 10000; // Default 10 seconds in ticks

    let eventsProcessed = 0;

    try {
      console.log(`üöÄ Starting tick-based simulation - queue size: ${eventQueue.getSize()}`);

      // Core event processing loop
      while (get().isRunning && !eventQueue.isEmpty()) {
        // Safety limit
        if (eventsProcessed >= maxEvents) {
          console.warn(`‚ö†Ô∏è Reached max events limit (${maxEvents})`);
          break;
        }

        // Get next event
        const event = eventQueue.dequeue();
        if (!event) break;

        // Stop tick limit
        if (event.timestamp > stopTick) {
          console.log(`‚èπÔ∏è Reached stop tick (${stopTick})`);
          break;
        }

        // Update current tick and time (convert to seconds for display)
        const currentTimeSeconds = event.simulationTimestamp / 1000;
        set({
          currentTick: event.timestamp,
          currentTime: currentTimeSeconds
        });

        // Process the event
        await get().processEvent(event);

        eventsProcessed++;

        // Real-time mode delay
        if (context.config.realTimeMode) {
          const speed = context.config.realTimeSpeed || 1;
          await new Promise(resolve => setTimeout(resolve, 10 / speed));
        }

        // Yield to browser for UI updates
        if (eventsProcessed % 10 === 0) {
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }

      console.log(`‚úÖ Simulation completed - processed ${eventsProcessed} events`);
    } catch (error) {
      console.error('‚ùå Error during execution:', error);
      set({ isRunning: false });
    } finally {
      const endTime = Date.now();

      set((state) => ({
        isRunning: false,
        stats: {
          ...state.stats,
          endTime,
          duration: endTime - startTime,
          eventsProcessed,
        },
      }));
    }

    return get().stats;
  },
  
  stop: () => {
    set({ isRunning: false });
  },
  
  processEvent: async (event) => {
    const { context } = get();

    if (!context) {
      throw new Error('No context set. Call initialize() first.');
    }

    // Update current tick and time
    set({ currentTick: event.timestamp, currentTime: event.simulationTimestamp });

    // Handle system events (like SimulationStart)
    if (event.sourceNodeId === 'system') {
      await get()._handleSystemEvent(event);
      return;
    }

    // Find target node
    const targetNodeId = event.sourceNodeId;
    const nodeConfig = context.scenario.nodes.find((n: any) => n.id === targetNodeId || n.nodeId === targetNodeId);

    if (!nodeConfig) {
      console.warn(`‚ö†Ô∏è Node ${targetNodeId} not found in scenario`);
      return;
    }

    // Get processor for node type
    const processor = nodeProcessorRegistry.get(nodeConfig.type);

    if (!processor) {
      console.warn(`‚ö†Ô∏è No processor registered for node type '${nodeConfig.type}'`);
      return;
    }

    try {
      // Get current node state
      let nodeState = context.nodeStates.get(targetNodeId);

      if (!nodeState) {
        // Initialize state if not exists
        nodeState = processor.initializeState(nodeConfig);
        context.nodeStates.set(targetNodeId, nodeState);
      }

      // Process event
      const result = processor.process(event, nodeConfig, nodeState);

      // Update node state
      context.nodeStates.set(targetNodeId, result.updatedState);

      // Handle new events
      const eventStore = useEventStore.getState();
      const eventQueue = useEventQueue.getState();

      for (const newEventData of result.newEvents) {
        // Add event to store
        const storedEvent = eventStore.appendEvent(newEventData);

        // Add event to queue (all events get processed, routing happens when processed)
        eventQueue.enqueue(storedEvent);
      }

      // Log to activity logger
      const activityLogger = useActivityLogger.getState();
      activityLogger.logFromEvent(event);

      // Update stats
      set((state) => ({
        stats: {
          ...state.stats,
          eventsByType: {
            ...state.stats.eventsByType,
            [event.type]: (state.stats.eventsByType[event.type] || 0) + 1,
          },
          eventsByNode: {
            ...state.stats.eventsByNode,
            [targetNodeId]: (state.stats.eventsByNode[targetNodeId] || 0) + 1,
          },
        },
      }));
    } catch (error) {
      console.error(`‚ùå Error processing event ${event.id}:`, error);

      set((state) => ({
        errors: [
          ...state.errors,
          {
            eventId: event.id,
            nodeId: targetNodeId,
            error: error as Error,
            timestamp: event.timestamp,
          },
        ],
        stats: {
          ...state.stats,
          errors: state.stats.errors + 1,
        },
      }));
    }

    // CRITICAL: If this was a DataEmit event, route token to connected nodes
    if (event.type === 'DataEmit') {
      const dataEmitData = event.data as any;
      const token = dataEmitData.token;

      if (token) {
        console.log(`üîÄ Routing DataEmit token from ${event.sourceNodeId}...`);

        // Route token to connected nodes
        const routedEvents = get()._routeTokenToTargets(
          event.sourceNodeId,
          token,
          event.timestamp,
          event.id
        );

        console.log(`üì§ Created ${routedEvents.length} TokenArrival events for connected nodes`);

        // Add TokenArrival events to queue
        const eventStore = useEventStore.getState();
        const eventQueue = useEventQueue.getState();

        for (const routedEvent of routedEvents) {
          const routedStoredEvent = eventStore.appendEvent(routedEvent);
          eventQueue.enqueue(routedStoredEvent);
        }
      }
    }
  },
  
  processNextEvent: async () => {
    const eventQueue = useEventQueue.getState();

    if (eventQueue.isEmpty()) {
      return false;
    }

    const event = eventQueue.dequeue();

    if (!event) {
      return false;
    }

    await get().processEvent(event);
    return true;
  },

  step: async () => {
    const { context } = get();

    if (!context) {
      throw new Error('No context set. Call initialize() first.');
    }

    const eventQueue = useEventQueue.getState();

    if (eventQueue.isEmpty()) {
      console.log('‚úÖ No more events to process');
      return null;
    }

    // Get next event
    const event = eventQueue.dequeue();
    if (!event) return null;

    // Update current tick and time (convert to seconds for display)
    const currentTimeSeconds = event.simulationTimestamp / 1000;
    set({
      currentTick: event.timestamp,
      currentTime: currentTimeSeconds
    });

    console.log(`‚è∞ Updated time to ${currentTimeSeconds}s (timestamp: ${event.timestamp})`);

    // Process the event - this generates output events and queues them automatically
    await get().processEvent(event);

    console.log(`üéØ Processed event: ${event.type} at tick ${event.timestamp} from ${event.sourceNodeId}`);

    return event;
  },
  
  // ============================================================================
  // STATE QUERIES
  // ============================================================================
  
  getNodeState: (nodeId) => {
    const { context } = get();
    return context?.nodeStates.get(nodeId) || null;
  },
  
  getAllNodeStates: () => {
    const { context } = get();
    return context?.nodeStates || new Map();
  },
  
  getStats: () => {
    return get().stats;
  },
  
  // ============================================================================
  // INTERNAL
  // ============================================================================
  
  _initializeNodeStates: () => {
    const { context } = get();
    
    if (!context) return;
    
    context.scenario.nodes.forEach((node: any) => {
      const processor = nodeProcessorRegistry.get(node.type);
      
      if (processor) {
        const state = processor.initializeState(node);
        context.nodeStates.set(node.id, state);
      }
    });
    
    console.log(`üì¶ Initialized ${context.nodeStates.size} node states`);
  },
  
  _buildEdgeMap: () => {
    const { context } = get();
    
    if (!context) return;
    
    const edgeMap = new Map<string, string[]>();
    
    console.log('üîó Building edge map from scenario:', {
      hasEdges: !!context.scenario.edges,
      edgesLength: context.scenario.edges?.length,
      hasNodes: !!context.scenario.nodes,
      nodesLength: context.scenario.nodes?.length
    });

    // Handle scenarios with explicit edges array (ReactFlow format)
    if (context.scenario.edges && Array.isArray(context.scenario.edges)) {
      console.log('üîó Found edges array:', context.scenario.edges);
      context.scenario.edges.forEach((edge: any) => {
        const source = edge.source;
        const target = edge.target;

        console.log(`üîó Adding edge: ${source} ‚Üí ${target}`);

        if (!edgeMap.has(source)) {
          edgeMap.set(source, []);
        }

        edgeMap.get(source)!.push(target);
      });
    } 
    // Otherwise, build from node outputs/connections if available
    else if (context.scenario.nodes && Array.isArray(context.scenario.nodes)) {
      console.log('‚ö†Ô∏è No edges array found, building edge map from node outputs...');
      
      context.scenario.nodes.forEach((node: any) => {
        // Check various output properties
        const outputs = node.outputs || node.connections || [];
        
        if (outputs.length > 0) {
          if (!edgeMap.has(node.nodeId)) {
            edgeMap.set(node.nodeId, []);
          }
          
          outputs.forEach((output: any) => {
            const targetId = output.targetNodeId || output.target || output;
            if (targetId && typeof targetId === 'string') {
              edgeMap.get(node.nodeId)!.push(targetId);
            }
          });
        }
      });
    }
    
    context.edgeMap = edgeMap;
    
    console.log(`üîó Built edge map with ${edgeMap.size} source nodes`);
  },
  
  _generateInitialEvents: () => {
    const { context } = get();

    if (!context) return;

    const eventQueue = useEventQueue.getState();
    const eventStore = useEventStore.getState();

    // Send SimulationStart to DataSource nodes - they will pre-generate all future events
    console.log('üîç Scenario nodes for initial events:', context.scenario.nodes.map(n => ({id: n.id || n.nodeId, type: n.type})));
    const dataSourceNodes = context.scenario.nodes.filter((node: any) =>
      node.type === 'DataSource' || node.type === 'DataSourceNode'
    );
    console.log('üîç Found DataSource nodes:', dataSourceNodes.map(n => ({id: n.id || n.nodeId, type: n.type})));

    for (const node of dataSourceNodes) {
      const startEvent = createEventAtTick(
        'SimulationStart',
        node.id || node.nodeId,
        0,
        {
          scenario: context.scenario.id || 'default',
        },
        {
          metadata: {
            context: 'simulation',
          },
        }
      );

      const storedStartEvent = eventStore.appendEvent(startEvent);
      eventQueue.enqueue(storedStartEvent);
    }

    console.log(`‚úÖ Generated SimulationStart for ${dataSourceNodes.length} DataSource nodes - queue size: ${eventQueue.getSize()}`);
  },
  
  _routeTokenToTargets: (sourceNodeId, token, tick, causedBy) => {
    const { context } = get();

    if (!context) {
      console.log(`‚ùå No context available for routing from ${sourceNodeId}`);
      return [];
    }

    const targetNodeIds = context.edgeMap.get(sourceNodeId) || [];

    console.log(`üîÄ Routing token from ${sourceNodeId} to targets:`, targetNodeIds);
    console.log(`üìã Available edges in map:`, Array.from(context.edgeMap.entries()));

    if (targetNodeIds.length === 0) {
      console.log(`‚ö†Ô∏è No targets found for ${sourceNodeId}. Edge map contents:`, {
        mapSize: context.edgeMap.size,
        allSources: Array.from(context.edgeMap.keys()),
        allTargets: Array.from(context.edgeMap.values()).flat()
      });
    }

    return targetNodeIds.map(targetNodeId =>
      createEventAtTick(
        'TokenArrival',
        targetNodeId, // CRITICAL FIX: Use targetNodeId, not 'ROUTER'
        tick,
        {
          toNodeId: targetNodeId,
          fromNodeId: sourceNodeId,
          token,
          inputName: 'default',
        },
        {
          causedBy,
          correlationIds: token.correlationIds,
          metadata: {
            context: 'simulation',
          },
        }
      )
    );
  },

  _handleSystemEvent: async (event) => {
    // No system events needed anymore - SimulationStart sent directly to nodes
    console.log(`‚ö†Ô∏è System event received but not handled: ${event.type}`);
  },

}));

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Quick start - initialize and run simulation
 */
export async function runSimulation(
  scenario: any,
  initialEvents: Omit<StoredEvent, 'id'>[],
  config?: ExecutionContext['config']
): Promise<ExecutionStats> {
  const processor = useEventProcessor.getState();
  const eventStore = useEventStore.getState();
  const eventQueue = useEventQueue.getState();
  
  // Reset
  processor.reset();
  
  // Initialize
  processor.initialize(scenario, config);
  
  // Add initial events
  const storedEvents = initialEvents.map(e => eventStore.appendEvent(e));
  eventQueue.enqueueAll(storedEvents);
  
  // Run
  return processor.start();
}

{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5e442b4ca747725532f16ab57936241568db736e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/IncrementalVerifiableClaim.sol": "project/contracts/IncrementalVerifiableClaim.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/IncrementalMerkleTree.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @notice Incremental Merkle Tree module\n *\n * This implementation is a modification of the Incremental Merkle Tree data structure described\n * in [Deposit Contract Verification](https://github.com/runtimeverification/deposit-contract-verification/blob/master/deposit-contract-verification.pdf).\n *\n * This implementation aims to optimize and improve the original data structure.\n *\n * The main differences are:\n * - No explicit constructor; the tree is initialized when the first element is added\n * - Growth is not constrained; the height of the tree automatically increases as elements are added\n *\n * Zero hashes are computed each time the getRoot function is called.\n *\n * Gas usage for _add and _root functions (where count is the number of elements added to the tree):\n *\n * | Statistic | _add         | _root            |\n * | --------- | ------------ | ---------------- |\n * | count     | 49999        | 49999            |\n * | mean      | 38972 gas    | 60213 gas        |\n * | std       | 3871 gas     | 4996 gas         |\n * | min       | 36251 gas    | 31238 gas        |\n * | 25%       | 36263 gas    | 57020 gas        |\n * | 50%       | 38954 gas    | 60292 gas        |\n * | 75%       | 41657 gas    | 63564 gas        |\n * | max       | 96758 gas    | 78071 gas        |\n *\n * ## Usage example:\n *\n * ```\n * using IncrementalMerkleTree for IncrementalMerkleTree.UintIMT;\n *\n * IncrementalMerkleTree.UintIMT internal uintTree;\n *\n * ................................................\n *\n * uintTree.add(1234);\n *\n * uintTree.root();\n *\n * uintTree.height();\n *\n * uintTree.length();\n * ```\n */\nlibrary IncrementalMerkleTree {\n    /**\n     *********************\n     *      UintIMT      *\n     *********************\n     */\n\n    struct UintIMT {\n        IMT _tree;\n    }\n\n    error NewHeightMustBeGreater(uint256 currentHeight, uint256 newHeight);\n    error TreeIsNotEmpty();\n    error TreeIsFull();\n\n    /**\n     * @notice The function to set the height of the uint256 tree.\n     * Complexity is O(1).\n     *\n     * @param tree self.\n     * @param height_ The new height of the Merkle tree. Should be greater than the current one.\n     */\n    function setHeight(UintIMT storage tree, uint256 height_) internal {\n        _setHeight(tree._tree, height_);\n    }\n\n    /**\n     * @notice The function to add a new element to the uint256 tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     *\n     * @param tree self.\n     * @param element_ The new element to add.\n     */\n    function add(UintIMT storage tree, uint256 element_) internal {\n        _add(tree._tree, bytes32(element_));\n    }\n\n    /**\n     * @notice The function to set a custom hash functions, that will be used to build the Merkle Tree.\n     *\n     * @param tree self.\n     * @param hash1_ The hash function that accepts one argument.\n     * @param hash2_ The hash function that accepts two arguments.\n     */\n    function setHashers(\n        UintIMT storage tree,\n        function(bytes32) view returns (bytes32) hash1_,\n        function(bytes32, bytes32) view returns (bytes32) hash2_\n    ) internal {\n        _setHashers(tree._tree, hash1_, hash2_);\n    }\n\n    /**\n     * @notice The function to return the root hash of the uint256 tree.\n     * Complexity is O(log(n) + h), where n is the number of elements in the tree and\n     * h is the height of the tree.\n     *\n     * @param tree self.\n     * @return The root hash of the Merkle tree.\n     */\n    function root(UintIMT storage tree) internal view returns (bytes32) {\n        return _root(tree._tree);\n    }\n\n    /**\n     * @notice The function to verify a proof of a leaf's existence in the uint256 tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     *\n     * @param tree self.\n     * @param siblings_ The siblings of the leaf.\n     * @param directionBits_ The direction bits of the leaf.\n     * @param leaf_ The leaf.\n     * @param root_ The root hash of the tree to verify against.\n     * @return True if the proof is valid, false otherwise.\n     */\n    function verifyProof(\n        UintIMT storage tree,\n        bytes32[] memory siblings_,\n        uint256 directionBits_,\n        bytes32 leaf_,\n        bytes32 root_\n    ) internal view returns (bool) {\n        return _verifyProof(tree._tree, siblings_, directionBits_, leaf_, root_);\n    }\n\n    /**\n     * @notice The function to return the height of the uint256 tree. Complexity is O(1).\n     * @param tree self.\n     * @return The height of the Merkle tree.\n     */\n    function height(UintIMT storage tree) internal view returns (uint256) {\n        return _height(tree._tree);\n    }\n\n    /**\n     * @notice The function to return the number of elements in the uint256 tree. Complexity is O(1).\n     * @param tree self.\n     * @return The number of elements in the Merkle tree.\n     */\n    function length(UintIMT storage tree) internal view returns (uint256) {\n        return _length(tree._tree);\n    }\n\n    /**\n     * @notice The function to check whether the custom hash functions are set.\n     * @param tree self.\n     * @return True if the custom hash functions are set, false otherwise.\n     */\n    function isCustomHasherSet(UintIMT storage tree) internal view returns (bool) {\n        return tree._tree.isCustomHasherSet;\n    }\n\n    /**\n     **********************\n     *     Bytes32IMT     *\n     **********************\n     */\n\n    struct Bytes32IMT {\n        IMT _tree;\n    }\n\n    /**\n     * @notice The function to set the height of the bytes32 tree.\n     * Complexity is O(1).\n     *\n     * @param tree self.\n     * @param height_ The new height of the Merkle tree. Should be greater than the current one.\n     */\n    function setHeight(Bytes32IMT storage tree, uint256 height_) internal {\n        _setHeight(tree._tree, height_);\n    }\n\n    /**\n     * @notice The function to add a new element to the bytes32 tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     */\n    function add(Bytes32IMT storage tree, bytes32 element_) internal {\n        _add(tree._tree, element_);\n    }\n\n    /**\n     * @notice The function to set a custom hash functions, that will be used to build the Merkle Tree.\n     *\n     * @param tree self.\n     * @param hash1_ The hash function that accepts one argument.\n     * @param hash2_ The hash function that accepts two arguments.\n     */\n    function setHashers(\n        Bytes32IMT storage tree,\n        function(bytes32) view returns (bytes32) hash1_,\n        function(bytes32, bytes32) view returns (bytes32) hash2_\n    ) internal {\n        _setHashers(tree._tree, hash1_, hash2_);\n    }\n\n    /**\n     * @notice The function to return the root hash of the bytes32 tree.\n     * Complexity is O(log(n) + h), where n is the number of elements in the tree and\n     * h is the height of the tree.\n     */\n    function root(Bytes32IMT storage tree) internal view returns (bytes32) {\n        return _root(tree._tree);\n    }\n\n    /**\n     * @notice The function to verify a proof of a leaf's existence in the bytes32 tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     *\n     * @param tree self.\n     * @param siblings_ The siblings of the leaf.\n     * @param directionBits_ The direction bits of the leaf.\n     * @param leaf_ The leaf.\n     * @param root_ The root hash of the tree to verify against.\n     * @return True if the proof is valid, false otherwise.\n     */\n    function verifyProof(\n        Bytes32IMT storage tree,\n        bytes32[] memory siblings_,\n        uint256 directionBits_,\n        bytes32 leaf_,\n        bytes32 root_\n    ) internal view returns (bool) {\n        return _verifyProof(tree._tree, siblings_, directionBits_, leaf_, root_);\n    }\n\n    /**\n     * @notice The function to process the proof for inclusion or exclusion of a leaf in the tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     *\n     * @param hash2_ The hash function that accepts two arguments.\n     * @param siblings_ The siblings of the leaf.\n     * @param directionBits_ The direction bits of the leaf.\n     * @param leaf_ The leaf.\n     * @return The calculated root hash from the proof.\n     */\n    function processProof(\n        function(bytes32, bytes32) view returns (bytes32) hash2_,\n        bytes32[] memory siblings_,\n        uint256 directionBits_,\n        bytes32 leaf_\n    ) internal view returns (bytes32) {\n        return _processProof(hash2_, siblings_, directionBits_, leaf_);\n    }\n\n    /**\n     * @notice The function to return the height of the bytes32 tree. Complexity is O(1).\n     */\n    function height(Bytes32IMT storage tree) internal view returns (uint256) {\n        return _height(tree._tree);\n    }\n\n    /**\n     * @notice The function to return the number of elements in the bytes32 tree. Complexity is O(1).\n     */\n    function length(Bytes32IMT storage tree) internal view returns (uint256) {\n        return _length(tree._tree);\n    }\n\n    /**\n     * @notice The function to check whether the custom hash functions are set.\n     * @param tree self.\n     * @return True if the custom hash functions are set, false otherwise.\n     */\n    function isCustomHasherSet(Bytes32IMT storage tree) internal view returns (bool) {\n        return tree._tree.isCustomHasherSet;\n    }\n\n    /**\n     ************************\n     *      AddressIMT      *\n     ************************\n     */\n\n    struct AddressIMT {\n        IMT _tree;\n    }\n\n    /**\n     * @notice The function to set the height of the address tree.\n     * Complexity is O(1).\n     *\n     * @param tree self.\n     * @param height_ The new height of the Merkle tree. Should be greater than the current one.\n     */\n    function setHeight(AddressIMT storage tree, uint256 height_) internal {\n        _setHeight(tree._tree, height_);\n    }\n\n    /**\n     * @notice The function to add a new element to the address tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     */\n    function add(AddressIMT storage tree, address element_) internal {\n        _add(tree._tree, bytes32(uint256(uint160(element_))));\n    }\n\n    /**\n     * @notice The function to set a custom hash functions, that will be used to build the Merkle Tree.\n     *\n     * @param tree self.\n     * @param hash1_ The hash function that accepts one argument.\n     * @param hash2_ The hash function that accepts two arguments.\n     */\n    function setHashers(\n        AddressIMT storage tree,\n        function(bytes32) view returns (bytes32) hash1_,\n        function(bytes32, bytes32) view returns (bytes32) hash2_\n    ) internal {\n        _setHashers(tree._tree, hash1_, hash2_);\n    }\n\n    /**\n     * @notice The function to return the root hash of the address tree.\n     * Complexity is O(log(n) + h), where n is the number of elements in the tree and\n     * h is the height of the tree.\n     */\n    function root(AddressIMT storage tree) internal view returns (bytes32) {\n        return _root(tree._tree);\n    }\n\n    /**\n     * @notice The function to verify a proof of a leaf's existence in the address tree.\n     * Complexity is O(log(n)), where n is the number of elements in the tree.\n     *\n     * @param tree self.\n     * @param siblings_ The siblings of the leaf.\n     * @param directionBits_ The direction bits of the leaf.\n     * @param leaf_ The leaf.\n     * @param root_ The root hash of the tree to verify against.\n     * @return True if the proof is valid, false otherwise.\n     */\n    function verifyProof(\n        AddressIMT storage tree,\n        bytes32[] memory siblings_,\n        uint256 directionBits_,\n        bytes32 leaf_,\n        bytes32 root_\n    ) internal view returns (bool) {\n        return _verifyProof(tree._tree, siblings_, directionBits_, leaf_, root_);\n    }\n\n    /**\n     * @notice The function to return the height of the address tree. Complexity is O(1).\n     */\n    function height(AddressIMT storage tree) internal view returns (uint256) {\n        return _height(tree._tree);\n    }\n\n    /**\n     * @notice The function to return the number of elements in the address tree. Complexity is O(1).\n     */\n    function length(AddressIMT storage tree) internal view returns (uint256) {\n        return _length(tree._tree);\n    }\n\n    /**\n     * @notice The function to check whether the custom hash functions are set.\n     * @param tree self.\n     * @return True if the custom hash functions are set, false otherwise.\n     */\n    function isCustomHasherSet(AddressIMT storage tree) internal view returns (bool) {\n        return tree._tree.isCustomHasherSet;\n    }\n\n    /**\n     ************************\n     *       InnerIMT       *\n     ************************\n     */\n\n    struct IMT {\n        bytes32[] branches;\n        uint256 leavesCount;\n        bool isStrictHeightSet;\n        bool isCustomHasherSet;\n        function(bytes32) view returns (bytes32) hash1;\n        function(bytes32, bytes32) view returns (bytes32) hash2;\n    }\n\n    function _setHeight(IMT storage tree, uint256 height_) private {\n        uint256 currentHeight_ = _height(tree);\n\n        if (height_ <= currentHeight_) revert NewHeightMustBeGreater(currentHeight_, height_);\n\n        tree.isStrictHeightSet = true;\n\n        assembly {\n            sstore(tree.slot, height_)\n        }\n    }\n\n    function _setHashers(\n        IMT storage tree,\n        function(bytes32) view returns (bytes32) hash1_,\n        function(bytes32, bytes32) view returns (bytes32) hash2_\n    ) private {\n        if (_length(tree) != 0) revert TreeIsNotEmpty();\n\n        tree.isCustomHasherSet = true;\n\n        tree.hash1 = hash1_;\n        tree.hash2 = hash2_;\n    }\n\n    function _add(IMT storage tree, bytes32 element_) private {\n        function(bytes32) view returns (bytes32) hash1_ = tree.isCustomHasherSet\n            ? tree.hash1\n            : _hash1;\n        function(bytes32, bytes32) view returns (bytes32) hash2_ = tree.isCustomHasherSet\n            ? tree.hash2\n            : _hash2;\n\n        bytes32 resultValue_ = hash1_(element_);\n\n        uint256 index_ = 0;\n        uint256 size_ = ++tree.leavesCount;\n        uint256 treeHeight_ = tree.branches.length;\n\n        while (index_ < treeHeight_) {\n            if (size_ & 1 == 1) {\n                break;\n            }\n\n            bytes32 branch_ = tree.branches[index_];\n            resultValue_ = hash2_(branch_, resultValue_);\n\n            size_ >>= 1;\n            ++index_;\n        }\n\n        if (index_ == treeHeight_) {\n            if (tree.isStrictHeightSet) revert TreeIsFull();\n\n            tree.branches.push(resultValue_);\n        } else {\n            tree.branches[index_] = resultValue_;\n        }\n    }\n\n    function _root(IMT storage tree) private view returns (bytes32) {\n        function(bytes32) view returns (bytes32) hash1_ = tree.isCustomHasherSet\n            ? tree.hash1\n            : _hash1;\n        function(bytes32, bytes32) view returns (bytes32) hash2_ = tree.isCustomHasherSet\n            ? tree.hash2\n            : _hash2;\n\n        uint256 treeHeight_ = tree.branches.length;\n\n        if (treeHeight_ == 0) {\n            return hash1_(bytes32(0));\n        }\n\n        uint256 height_;\n        uint256 size_ = tree.leavesCount;\n        bytes32 root_ = hash1_(bytes32(0));\n        bytes32[] memory zeroHashes_ = _getZeroHashes(tree, treeHeight_);\n\n        while (height_ < treeHeight_) {\n            if (size_ & 1 == 1) {\n                bytes32 branch_ = tree.branches[height_];\n\n                root_ = hash2_(branch_, root_);\n            } else {\n                bytes32 zeroHash_ = zeroHashes_[height_];\n\n                root_ = hash2_(root_, zeroHash_);\n            }\n\n            size_ >>= 1;\n            ++height_;\n        }\n\n        return root_;\n    }\n\n    function _verifyProof(\n        IMT storage tree,\n        bytes32[] memory siblings_,\n        uint256 directionBits,\n        bytes32 leaf_,\n        bytes32 root_\n    ) private view returns (bool) {\n        function(bytes32, bytes32) view returns (bytes32) hash2_ = tree.isCustomHasherSet\n            ? tree.hash2\n            : _hash2;\n\n        return _processProof(hash2_, siblings_, directionBits, leaf_) == root_;\n    }\n\n    function _processProof(\n        function(bytes32, bytes32) view returns (bytes32) hash2_,\n        bytes32[] memory siblings_,\n        uint256 directionBits,\n        bytes32 leaf_\n    ) private view returns (bytes32) {\n        bytes32 computedHash_ = leaf_;\n\n        for (uint256 i = 0; i < siblings_.length; ++i) {\n            if ((directionBits >> i) & 1 != 0) {\n                computedHash_ = hash2_(siblings_[i], computedHash_);\n            } else {\n                computedHash_ = hash2_(computedHash_, siblings_[i]);\n            }\n        }\n\n        return computedHash_;\n    }\n\n    function _height(IMT storage tree) private view returns (uint256) {\n        return tree.branches.length;\n    }\n\n    function _length(IMT storage tree) private view returns (uint256) {\n        return tree.leavesCount;\n    }\n\n    function _getZeroHashes(\n        IMT storage tree,\n        uint256 height_\n    ) private view returns (bytes32[] memory) {\n        function(bytes32) view returns (bytes32) hash1_ = tree.isCustomHasherSet\n            ? tree.hash1\n            : _hash1;\n        function(bytes32, bytes32) view returns (bytes32) hash2_ = tree.isCustomHasherSet\n            ? tree.hash2\n            : _hash2;\n\n        bytes32[] memory zeroHashes_ = new bytes32[](height_);\n\n        zeroHashes_[0] = hash1_(bytes32(0));\n\n        for (uint256 i = 1; i < height_; ++i) {\n            bytes32 prevHash_ = zeroHashes_[i - 1];\n\n            zeroHashes_[i] = hash2_(prevHash_, prevHash_);\n        }\n\n        return zeroHashes_;\n    }\n\n    function _hash1(bytes32 a) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0, a)\n\n            result := keccak256(0, 32)\n        }\n    }\n\n    function _hash2(bytes32 a, bytes32 b) private pure returns (bytes32 result) {\n        assembly {\n            mstore(0, a)\n            mstore(32, b)\n\n            result := keccak256(0, 64)\n        }\n    }\n}"
      },
      "project/contracts/IncrementalVerifiableClaim.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./IncrementalMerkleTree.sol\";\n\n/**\n * @title IncrementalVerifiableClaim\n * @notice NFT-like claims that can be updated incrementally with new events\n * @dev Uses Incremental Merkle Trees for append-only, gas-efficient updates\n *\n * Key Features:\n * - Mint claims with initial ledger and sink events\n * - Append new events securely (cannot modify old events)\n * - Verify Merkle proofs on-chain\n * - Track aggregate values and metadata\n * - Version history via events\n */\ncontract IncrementalVerifiableClaim {\n    using IncrementalMerkleTree for IncrementalMerkleTree.Bytes32IMT;\n\n    // ============================================================================\n    // STRUCTS\n    // ============================================================================\n\n    struct ClaimData {\n        string claimId;              // Off-chain claim ID\n        string workflowId;           // Template/workflow ID\n        string executionId;          // Execution instance ID\n\n        // Incremental Merkle Trees (secure append-only)\n        IncrementalMerkleTree.Bytes32IMT ledgerTree;  // ALL execution events\n        IncrementalMerkleTree.Bytes32IMT sinkTree;    // ONLY sink events\n\n        // Aggregate & Metadata\n        string aggregateValue;       // Computed claim value (stringified JSON)\n        string metadataUri;          // URI to off-chain metadata (IPFS)\n\n        // Timestamps\n        uint256 createdAt;           // When claim was minted\n        uint256 lastUpdatedAt;       // When last events were appended\n\n        // Ownership\n        address owner;               // Current owner\n    }\n\n    // ============================================================================\n    // STATE VARIABLES\n    // ============================================================================\n\n    /// @notice Mapping from token ID to claim data (internal storage)\n    mapping(uint256 => ClaimData) internal claims;\n\n    /// @notice Mapping from token ID to owner address\n    mapping(uint256 => address) public ownerOf;\n\n    /// @notice Mapping from owner to token count\n    mapping(uint256 => uint256) public balanceOf;\n\n    /// @notice Contract deployer (can mint claims)\n    address public immutable deployer;\n\n    /// @notice Array of all token IDs (for enumeration)\n    uint256[] private _allTokens;\n\n    /// @notice Mapping from token ID to index in _allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /// @notice Total number of tokens minted\n    uint256 private _totalSupply;\n\n    // ============================================================================\n    // EVENTS\n    // ============================================================================\n\n    event ClaimMinted(\n        uint256 indexed tokenId,\n        address indexed to,\n        string claimId,\n        uint256 initialLedgerEvents,\n        uint256 initialSinkEvents\n    );\n\n    event EventsAppended(\n        uint256 indexed tokenId,\n        uint256 newLedgerCount,\n        uint256 newSinkCount,\n        bytes32 newLedgerRoot,\n        bytes32 newSinkRoot,\n        string newAggregateValue\n    );\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event AggregateUpdated(\n        uint256 indexed tokenId,\n        string oldValue,\n        string newValue\n    );\n\n    // ============================================================================\n    // MODIFIERS\n    // ============================================================================\n\n    modifier onlyDeployer() {\n        require(msg.sender == deployer, \"Only deployer can call\");\n        _;\n    }\n\n    modifier tokenExists(uint256 tokenId) {\n        require(ownerOf[tokenId] != address(0), \"Token does not exist\");\n        _;\n    }\n\n    modifier onlyOwner(uint256 tokenId) {\n        require(ownerOf[tokenId] == msg.sender, \"Not token owner\");\n        _;\n    }\n\n    // ============================================================================\n    // CONSTRUCTOR\n    // ============================================================================\n\n    constructor() {\n        deployer = msg.sender;\n    }\n\n    // ============================================================================\n    // MINTING FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Mints a new claim NFT with initial events\n     * @param to Address to mint the claim to\n     * @param claimId Off-chain claim ID (also used to compute deterministic tokenId)\n     * @param workflowId Workflow template ID\n     * @param executionId Execution instance ID\n     * @param initialLedgerEvents Array of event hashes for full ledger\n     * @param initialSinkEvents Array of event hashes for sink\n     * @param aggregateValue Computed claim value\n     * @param metadataUri IPFS URI to claim metadata\n     * @return tokenId The minted token ID (deterministic based on claimId)\n     */\n    function mintClaim(\n        address to,\n        string memory claimId,\n        string memory workflowId,\n        string memory executionId,\n        bytes32[] memory initialLedgerEvents,\n        bytes32[] memory initialSinkEvents,\n        string memory aggregateValue,\n        string memory metadataUri\n    ) public returns (uint256) {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(initialLedgerEvents.length > 0, \"Need at least one ledger event\");\n\n        // Generate deterministic tokenId from claimId hash\n        uint256 tokenId = uint256(keccak256(abi.encodePacked(claimId)));\n        require(ownerOf[tokenId] == address(0), \"Token ID already exists\");\n\n        ClaimData storage claim = claims[tokenId];\n        claim.claimId = claimId;\n        claim.workflowId = workflowId;\n        claim.executionId = executionId;\n        claim.aggregateValue = aggregateValue;\n        claim.metadataUri = metadataUri;\n        claim.createdAt = block.timestamp;\n        claim.lastUpdatedAt = block.timestamp;\n        claim.owner = to;\n\n        // Add initial ledger events to IMT\n        for (uint256 i = 0; i < initialLedgerEvents.length; i++) {\n            claim.ledgerTree.add(initialLedgerEvents[i]);\n        }\n\n        // Add initial sink events to IMT\n        for (uint256 i = 0; i < initialSinkEvents.length; i++) {\n            claim.sinkTree.add(initialSinkEvents[i]);\n        }\n\n        // Update ownership mappings\n        ownerOf[tokenId] = to;\n        balanceOf[uint256(uint160(to))]++;\n\n        // Add to enumeration\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n        _totalSupply++;\n\n        emit ClaimMinted(\n            tokenId,\n            to,\n            claimId,\n            initialLedgerEvents.length,\n            initialSinkEvents.length\n        );\n        emit Transfer(address(0), to, tokenId);\n\n        return tokenId;\n    }\n\n    // ============================================================================\n    // UPDATE FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Appends new events to an existing claim\n     * @dev This is SECURE because IMT prevents modification of old events\n     * @param tokenId Token ID to update\n     * @param newLedgerEvents New ledger event hashes to append\n     * @param newSinkEvents New sink event hashes to append\n     * @param newAggregateValue Updated aggregate value\n     */\n    function appendEvents(\n        uint256 tokenId,\n        bytes32[] memory newLedgerEvents,\n        bytes32[] memory newSinkEvents,\n        string memory newAggregateValue\n    ) public onlyOwner(tokenId) tokenExists(tokenId) {\n        ClaimData storage claim = claims[tokenId];\n\n        string memory oldAggregate = claim.aggregateValue;\n\n        // Append to ledger tree (O(log n) per event)\n        for (uint256 i = 0; i < newLedgerEvents.length; i++) {\n            claim.ledgerTree.add(newLedgerEvents[i]);\n        }\n\n        // Append to sink tree\n        for (uint256 i = 0; i < newSinkEvents.length; i++) {\n            claim.sinkTree.add(newSinkEvents[i]);\n        }\n\n        // Update aggregate value and timestamp\n        claim.aggregateValue = newAggregateValue;\n        claim.lastUpdatedAt = block.timestamp;\n\n        emit EventsAppended(\n            tokenId,\n            claim.ledgerTree.length(),\n            claim.sinkTree.length(),\n            claim.ledgerTree.root(),\n            claim.sinkTree.root(),\n            newAggregateValue\n        );\n\n        emit AggregateUpdated(tokenId, oldAggregate, newAggregateValue);\n    }\n\n    /**\n     * @notice Updates only the aggregate value (no new events)\n     * @param tokenId Token ID to update\n     * @param newAggregateValue New aggregate value\n     */\n    function updateAggregate(\n        uint256 tokenId,\n        string memory newAggregateValue\n    ) public onlyOwner(tokenId) tokenExists(tokenId) {\n        ClaimData storage claim = claims[tokenId];\n        string memory oldValue = claim.aggregateValue;\n\n        claim.aggregateValue = newAggregateValue;\n        claim.lastUpdatedAt = block.timestamp;\n\n        emit AggregateUpdated(tokenId, oldValue, newAggregateValue);\n    }\n\n    // ============================================================================\n    // VIEW FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Gets the current state of a claim\n     * @param tokenId Token ID\n     * @return ledgerRoot Current root hash of ledger tree\n     * @return ledgerEventCount Number of events in ledger\n     * @return sinkRoot Current root hash of sink tree\n     * @return sinkEventCount Number of events in sink\n     * @return aggregateValue Current aggregate value\n     */\n    function getClaimState(uint256 tokenId) public view tokenExists(tokenId) returns (\n        bytes32 ledgerRoot,\n        uint256 ledgerEventCount,\n        bytes32 sinkRoot,\n        uint256 sinkEventCount,\n        string memory aggregateValue\n    ) {\n        ClaimData storage claim = claims[tokenId];\n        return (\n            claim.ledgerTree.root(),\n            claim.ledgerTree.length(),\n            claim.sinkTree.root(),\n            claim.sinkTree.length(),\n            claim.aggregateValue\n        );\n    }\n\n    /**\n     * @notice Gets claim metadata\n     * @param tokenId Token ID\n     * @return claimId Off-chain claim identifier\n     * @return workflowId Workflow template identifier\n     * @return executionId Execution instance identifier\n     * @return aggregateValue Current aggregate value\n     * @return metadataUri IPFS metadata URI\n     * @return createdAt Creation timestamp\n     * @return lastUpdatedAt Last update timestamp\n     * @return owner Current owner address\n     */\n    function getClaimMetadata(uint256 tokenId) public view tokenExists(tokenId) returns (\n        string memory claimId,\n        string memory workflowId,\n        string memory executionId,\n        string memory aggregateValue,\n        string memory metadataUri,\n        uint256 createdAt,\n        uint256 lastUpdatedAt,\n        address owner\n    ) {\n        ClaimData storage claim = claims[tokenId];\n        return (\n            claim.claimId,\n            claim.workflowId,\n            claim.executionId,\n            claim.aggregateValue,\n            claim.metadataUri,\n            claim.createdAt,\n            claim.lastUpdatedAt,\n            claim.owner\n        );\n    }\n\n    /**\n     * @notice Gets the metadata URI for a token (ERC721 compatible)\n     * @param tokenId Token ID\n     * @return string metadata URI\n     */\n    function tokenURI(uint256 tokenId) public view tokenExists(tokenId) returns (string memory) {\n        return claims[tokenId].metadataUri;\n    }\n\n    /**\n     * @notice Returns the total supply of tokens\n     * @return uint256 Total number of minted tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @notice Get token ID by index (ERC721Enumerable)\n     * @param index Index in the token array\n     * @return uint256 Token ID at the given index\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < _totalSupply, \"Index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @notice Get all token IDs\n     * @return uint256[] Array of all token IDs\n     */\n    function getAllTokenIds() public view returns (uint256[] memory) {\n        return _allTokens;\n    }\n\n    // ============================================================================\n    // VERIFICATION FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Verifies a Merkle proof for a ledger event\n     * @param tokenId Token ID to verify against\n     * @param siblings Array of sibling hashes (Merkle proof)\n     * @param directionBits Packed bits indicating path (0=left, 1=right)\n     * @param eventHash Hash of the event to verify\n     * @return bool Whether the proof is valid\n     */\n    function verifyLedgerEvent(\n        uint256 tokenId,\n        bytes32[] memory siblings,\n        uint256 directionBits,\n        bytes32 eventHash\n    ) public view tokenExists(tokenId) returns (bool) {\n        ClaimData storage claim = claims[tokenId];\n        bytes32 expectedRoot = claim.ledgerTree.root();\n\n        return claim.ledgerTree.verifyProof(\n            siblings,\n            directionBits,\n            eventHash,\n            expectedRoot\n        );\n    }\n\n    /**\n     * @notice Verifies a Merkle proof for a sink event\n     * @param tokenId Token ID to verify against\n     * @param siblings Array of sibling hashes (Merkle proof)\n     * @param directionBits Packed bits indicating path (0=left, 1=right)\n     * @param eventHash Hash of the event to verify\n     * @return bool Whether the proof is valid\n     */\n    function verifySinkEvent(\n        uint256 tokenId,\n        bytes32[] memory siblings,\n        uint256 directionBits,\n        bytes32 eventHash\n    ) public view tokenExists(tokenId) returns (bool) {\n        ClaimData storage claim = claims[tokenId];\n        bytes32 expectedRoot = claim.sinkTree.root();\n\n        return claim.sinkTree.verifyProof(\n            siblings,\n            directionBits,\n            eventHash,\n            expectedRoot\n        );\n    }\n\n    // ============================================================================\n    // TRANSFER FUNCTIONS\n    // ============================================================================\n\n    /**\n     * @notice Transfers a token from one address to another\n     * @param from Current owner\n     * @param to New owner\n     * @param tokenId Token to transfer\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public tokenExists(tokenId) {\n        require(ownerOf[tokenId] == from, \"From address is not owner\");\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(msg.sender == from, \"Not authorized to transfer\");\n\n        // Update balances\n        balanceOf[uint256(uint160(from))]--;\n        balanceOf[uint256(uint160(to))]++;\n\n        // Transfer ownership\n        ownerOf[tokenId] = to;\n        claims[tokenId].owner = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n}\n"
      }
    }
  }
}